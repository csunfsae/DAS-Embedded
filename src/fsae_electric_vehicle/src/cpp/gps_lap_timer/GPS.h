#pragma once

#include <cstdint>
#include <iostream>
#include <cassert>
#include "CANController.h"
#include <fsae_electric_vehicle/gps.h> // This gps.h is generated by ROS

//#define float double // For MSVC

#define MIN(x, y)                     (((x) < (y)) ? (x) : (y))
#define MAX(x, y)                     (((x) > (y)) ? (x) : (y))
#define DEGTORAD(deg)                 (deg*57.29577995f)
#define D_TO_RADIANS                  (PI/180.0f)

// GPS RMC sentence fields.
#define GPS_HOUR				0
#define GPS_MINUTES				1
#define GPS_SECONDS				2
#define GPS_FIX      			3
#define GPS_SPEED    			4
#define GPS_HEADING_1			5
#define GPS_HEADING_2			6

#define GPS_ONE_FRAME_ONE_ID	0x35	// Contains data that isnt latitude & longitude. Includes fix, time, heading....
#define GPS_ONE_FRAME_TWO_ID	0x36	// Contains latitude & longitude data
#define GPS_TWO_FRAME_ONE_ID	0x37	// Contains data that isnt latitude & longitude. Includes fix, time, heading....
#define GPS_TWO_FRAME_TWO_ID	0x38	// Contains latitude & longitude data

#define LATITUDE                      0x01
#define LONGITUDE                     0x02

struct point_t { float x, y; };
struct line_t { point_t p0, p1; };

static void FillRosMessageWithFrameTwoData(fsae_electric_vehicle::gps*, std::optional<CANData>);
static void FillRosMessageWithFrameOneData(fsae_electric_vehicle::gps*, std::optional<CANData>);
static void GetGPSData(CANController* can,
						std::pair<std::optional<CANData>, std::optional<CANData>> gpsUnitOneData,
						std::pair<std::optional<CANData>, std::optional<CANData>> gpsUnitTwoData);
static float EstablishStartLine(const std::pair<std::optional<CANData>, std::optional<CANData>>);
static void Run(float, char *[]);
static float Distance(const point_t, const point_t);
static void IntersectPoint(const point_t, const point_t, point_t*);
static bool LineIntersection(const line_t);
static void StartLine(const point_t, const float);
static bool readCanbusGPSData(CANController &can, CANData*);
static bool GetRMCSentence(char* []);
static float atof_(char []);
static char* strtok_(char*, const char*);
static char hex(const char);
static float ConvertToSeconds(char*);
static bool Equal(float, float);
static bool Within30(const uint16_t , const uint16_t);
static void GeoCopy(const char*, char*, const unsigned char);
static void Prepend(char*, const char*);
static size_t ParseRMC(char*, char* []);
static bool Checksum(char*);
static void DisplayTime(const uint8_t, const float);






// GPS update frequency and period.
const std::size_t GPS_UPDATE_FREQUENCY = 5; // Hz.
static constexpr float GPS_UPDATE_PERIOD{ 1.0f/GPS_UPDATE_FREQUENCY };

// Distance calculations.
static constexpr float PI{ 3.141592654 };
static constexpr float EARTH_RADIUS{ 3956.0 }; // In miles. 

// Definitions for the startline.
static constexpr float LINE_WIDTH{ 50.0f };
static constexpr float LINE_WIDTH_2{ 25.0f };
static constexpr float PROJECTION_DISTANCE{ 100.0f };



// Lap time class.
// This should be defined as a class imo
struct lap
{
public:
	void setStart(const float t)
	{
		assert(t >= 0.0f);
		start = t;
	}

	void setStop(const float t)
	{ 
		assert(t >= 0.0f);
		stop = t;
	}

	float getStart() const { return start; }
	float getStop() const { return stop; }
	
	float getLapDuration() const 
	{
		if (stop < start)
			return 0.0f;

		return (stop - start);
	}

private:
	static float toTimeStamp(float seconds)
	{
		uint16_t hours = (uint16_t)(seconds / 3600);
		uint16_t minutes = (uint16_t)(seconds / 60 - (hours * 60));
		float fs = seconds - (uint16_t)(seconds / 100) * 100;
		float timestamp = (((hours * 100) + minutes) * 100) + fs;

		return timestamp;
	}

	static float toSeconds(float time)
	{
		uint16_t hm = (uint16_t)(time / 100);
		uint16_t hours = (uint16_t)(time / 10000);
		uint16_t minutes = (hm - (hours * 100) + (hours * 60));
		float seconds = time - (hm * 100) + (minutes * 60);

		return seconds;
	}

	float start;
	float stop;
};



// Error descriptions.
static const char* description[] = { "NO ERROR",  "CHECKSUM FAILURE", "INVALID SENTENCE", "NO FIX", "NON-SEQUENTIAL SENTENCE", "END OF FILE" };

// Simplistic error tracker.
struct err
{
public:
	enum ID : size_t { NONE = 0, CHECKSUM, BAD_SENTENCE, NO_FIX, TIME_STAMP, FILE_EOF };

	void Clear() { error_ = ID::NONE; }
	void SetError(const ID id) { error_ = id; }
	ID GetError() const { return error_; }
	const char* GetDescription() const { return description[error_]; }

private:
	ID error_;
};

// File is used for testing. It replaces the data coming from the CANBUS
//#define FILE_INPUT

#ifdef FILE_INPUT
const char* filePath = "/home/btc54/Desktop/formulaEmbedded/src/fsae_electric_vehicle/src/cpp/gps_lap_timer/data.txt";
FILE* file = NULL;
bool FILE_INPUT_EOF = false;
#endif